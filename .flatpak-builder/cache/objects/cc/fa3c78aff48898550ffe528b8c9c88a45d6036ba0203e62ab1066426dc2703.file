from datetime import datetime, timedelta
from .database import DatabaseManager

class RevisionLogic:
    def __init__(self):
        self.db = DatabaseManager()

    def create_topic_with_revisions(self, title, area, start_date_str, tags, color, description=""):
        """Creates a topic. Revisions are scheduled only after first study session."""
        if not tags:
            tags = "Estudo"
            
        topic_id = self.db.add_topic(title, area, start_date_str, tags, color, description)
        
        # Schedule the "0-day" revision (The initial study)
        self.db.add_revision(topic_id, start_date_str, 0)
            
        return topic_id

    def register_study_session(self, topic_id, duration_seconds):
        """Records study time and marks today's revision as studied."""
        self.db.update_time_spent(topic_id, duration_seconds)
        
        # Check if there is a pending revision for TODAY (or overdue) to mark as studied
        today_str = datetime.now().strftime('%Y-%m-%d')
        revisions = self.db.get_revisions_for_topic(topic_id)
        
        target_rev_id = None
        for rev in revisions:
            # rev: (id, topic_id, scheduled_date, status, interval_days, ...)
            rev_date = rev[2]
            status = rev[3]
            if status == 'pending' and rev_date <= today_str:
                target_rev_id = rev[0]
                break
        
        if target_rev_id:
            self.mark_as_studied(target_rev_id)

    def mark_as_studied(self, revision_id):
        """Marks a revision as studied. Creates new cycle if interval is 0 or 30."""
        self.db.update_revision_status(revision_id, 'studied')
        
        # Check interval to see if we need to create/restart cycle
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT interval_days, topic_id, scheduled_date FROM revisions WHERE id = ?", (revision_id,))
        row = cursor.fetchone()
        
        if row:
            interval, topic_id, scheduled_date = row
            
            # Create cycle on first study (interval 0) OR on 30-day completion
            if interval == 0 or interval == 30:
                start_date = datetime.strptime(scheduled_date, '%Y-%m-%d')
                intervals = [7, 15, 30]
                
                # Check setting
                skip_weekends = self.db.get_setting('skip_weekends', 'False') == 'True'
                
                # Check existing revisions to avoid duplicates
                cursor.execute("SELECT interval_days FROM revisions WHERE topic_id = ?", (topic_id,))
                existing_intervals = {r[0] for r in cursor.fetchall()}
                
                for new_interval in intervals:
                    if new_interval not in existing_intervals:
                        rev_date_obj = start_date + timedelta(days=new_interval)
                        
                        if skip_weekends:
                            # If it falls on Sat (5) or Sun (6), move to Monday
                            while rev_date_obj.weekday() >= 5:
                                rev_date_obj += timedelta(days=1)
                        
                        rev_date = rev_date_obj.strftime('%Y-%m-%d')
                        self.db.add_revision(topic_id, rev_date, new_interval)

    def mark_as_pending(self, revision_id):
        """Reverts a revision status to pending."""
        self.db.update_revision_status(revision_id, 'pending')

    def mark_as_not_studied(self, revision_id, topic_id):
        """
        Marks a revision as missed, moves it to the next day,
        and shifts all subsequent revisions for that topic.
        """
        # 1. Get all revisions for this topic to find the sequence
        revisions = self.db.get_revisions_for_topic(topic_id)
        
        # Check setting
        skip_weekends = self.db.get_setting('skip_weekends', 'False') == 'True'
        
        # 2. Find target revision and shift it + all following ones
        found_target = False
        for rev in revisions:
            rev_id, t_id, scheduled_date_str, status, interval = rev
            
            if rev_id == revision_id:
                found_target = True
                
            if found_target:
                # Calculate new date (+1 day)
                current_date = datetime.strptime(scheduled_date_str, '%Y-%m-%d')
                new_date_obj = current_date + timedelta(days=1)
                
                if skip_weekends:
                    # If it falls on Sat or Sun, move to Monday
                    while new_date_obj.weekday() >= 5:
                        new_date_obj += timedelta(days=1)
                
                new_date = new_date_obj.strftime('%Y-%m-%d')
                self.db.update_revision_date(rev_id, new_date)
                
                # Re-marking as pending for the new date
                if rev_id == revision_id:
                    self.db.update_revision_status(rev_id, 'pending')

    def get_upcoming_revisions(self, date_str=None):
        """Returns revisions scheduled for a specific date (defaults to today)."""
        if date_str is None:
            date_str = datetime.now().strftime('%Y-%m-%d')
            
        cursor = self.db.conn.cursor()
        cursor.execute('''
            SELECT r.id, r.topic_id, r.scheduled_date, r.status, r.interval_days, t.title, t.area, COALESCE(a.color, t.color)
            FROM revisions r
            JOIN topics t ON r.topic_id = t.id
            LEFT JOIN areas a ON t.area = a.name
            WHERE r.scheduled_date = ?
            ORDER BY t.title
        ''', (date_str,))
        return cursor.fetchall()

    def get_today_stats(self):
        """Returns statistics for the current day."""
        today = datetime.now().strftime('%Y-%m-%d')
        
        # Pending topics
        revisions = self.get_upcoming_revisions(today)
        pending_count = sum(1 for rev in revisions if rev[3] == 'pending')
        completed_count = sum(1 for rev in revisions if rev[3] == 'studied')
        
        # Total study time today
        duration_seconds = self.db.get_study_time_for_date(today)
        
        return {
            'pending_count': pending_count,
            'completed_count': completed_count,
            'total_duration': duration_seconds
        }

    def sync_revisions_to_start_date(self, topic_id, new_start_date_str):
        """Updates the initial revision date if it hasn't been studied yet."""
        cursor = self.db.conn.cursor()
        cursor.execute("SELECT id FROM revisions WHERE topic_id = ? AND interval_days = 0 AND status = 'pending'", (topic_id,))
        row = cursor.fetchone()
        if row:
            self.db.update_revision_date(row[0], new_start_date_str)
        self.db.conn.commit()
